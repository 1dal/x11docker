#!/bin/bash

# ToDo:
# - work on hardware acceleration: try get docker accelerated with X over tcp instead of shared X socket, further tests with virtualgl
# - check pulseaudio: daemon on host seems to quit when image terminates
# - improve usage informations in gui

# x11docker changelog
# 10.10.2016  V1.1.3  unified --verbose and --VERBOSE to --verbose
#                     fixed help message if running as root without option --root
# 08.10.2016          developer options --devel --xhost --virtualgl
#                     bugfix: tail -F for log now shows all files frm beginning. was missing --retry -n +1
#                     change --orphaned: remove all cache files 
# 06.10.2016  V1.1.2  back to X over tcp. Marked --gpu as experimental. --gpu still with shared socket
# 05.10.2016  V1.1.1  --glamor: added again
#                     using /tmp/x11docker instead of ~.cache/x11docker
# 04.10.2016          disabled X over tcp, sharing new X socket instead.
#                     authentication with xhost +SI:localuser:user and cookie.
# 04.10.2016  V1.1.0  --gpu new option for hardware acceleration. drawback= needs xhost +SI:localhost:user instead of cookie, but no tcp
#                     removed --glamor, keep it as default
#                     set tty to use for core X server with $NEWXVT
#                     enabled SelectToClipboard in xterm
# 02.10.2016          --glamor: new option enables Xephyr 2d acceleration
#                     enabled many X extensions
# 01.10.2016          bugfix: removed -glamor in Xephyr for better support of kwin, added +extension GLX +extension RENDER +extension RANDR
# 30.09.2016  V 1.0.5 improved --orphaned; create named containers to check for
#                     rename option --zombiecheck to --orphaned
# 30.09.2016  V 1.0.4 improved creating desktop starter: prompting for name
#                     check for existing $BGPIDFILE on exit to avoid error message
# 29.09.2016  V 1.0.3 new option --pulseaudio: sound with pulseaudio over tcp
# 24.09.2016  V 1.0.2 new upload on github
# 24.09.2016          New option --no-xhost: disable any access to host X server granted by xhost
#                     Fixed minor bug: set xkbmap in xephyr after XAUTHORITY&DISPLAY has been set
#                     Set STARTXAUTHORITY as $HOME/.Xauthority if $XAUTHORITY is empty
#                     Exit on error while parsing options
#                     Avoid error message of xclip setting empty CLIP to " "
# 23.09.2016          new option: orphaned. Check for not cleanly removed containers and cache files
# 05.09.2016          bugfix: parsing $IMAGECOMMAND
#                     included MIT license text in script.
#                     waiting up to 10 instead of 5 seconds for docker to terminate
# 01.09.2016          some scripting improvements
# 30.08.2016          bugfix: cache folder was prevented from being deleted
#                     create symbolic link in $HOME to ~/.local/share/x11docker
#                     change CACHEFOLDER from ~/.cache/x11docker to /tmp/x11docker
#                     create file bgpids on init to avoid error message on option --help
#                     show warning if running pure X with window manager without logout option
# 28.10.2015          improved shared clipboard with Xephyr / minor bug fix for clips with more than 1 line
#                     removing not allowed chars in desktop starter file names
#                     finish(): make sure only cache subfolder will be deleted
# 25.10.2015  V 1.0.1 options --log and --LOG - show log in terminal on display :0 or new display
# 24.10.2015          minor bug fix: parsing: replaced sed with cut ( "/" in $IMAGECOMMAND caused sed bug)
# 20.10.2015          improved exit handling
# 16.10.2015  V 1.0

usage() {    # --help: show usage information
    echo "
x11docker: Create a new X server & run GUI applications and desktop 
         environments in docker and show them on your display.
         Useful to avoid security issues concerning X forwarding.
         Doesn't have dependencies inside of docker images.

If using X11 server from Xorg (default, least dependencies):
 * To start x11docker from console, switch to tty1 with <CTRL><ALT><F1>.
 * To start x11docker from within X11, first run 'dpkg-reconfigure x11-common'
   and choose option 'anybody'.
 * To switch between displays/X servers press <CTRL><ALT><F7>...<F12>
If using Xpra or Xephyr (recommended, see options '--xpra' and '--xephyr'):
 * The dockered applications will appear on your normal display.
   (needs no tty switching, 'x11-common' doesn't need to be changed)
 
Usage:
To run a docker image with new X server:
   x11docker [OPTIONS] IMAGE [COMMAND]
   x11docker [OPTIONS] -- [DOCKER_RUN_OPTIONS] IMAGE [COMMAND [ARG1 ARG2 ...]]
To run a host application on a new X server:
   x11docker [OPTIONS] --exe COMMAND
   x11docker [OPTIONS] --exe -- COMMAND [ARG1 ARG2 ...]
To run only a new X server with window manager:
   x11docker [OPTIONS]

 * The new X server will be terminated when [docker] application is closed.
 * On systems without a root password, like Ubuntu, use option '--sudo'.
 * x11docker is designed to run images only. New containers will be discarded.

Options:
 -h, --help            display this message and exit
 --license             show license of script (MIT)
 -w, --wm COMMAND      window manager to use (otherwise, x11docker tries to run
                       a new instance of the current running window manager; if
                       that's not possible, it will look for a recommended one)
 -d, --desktop         don't run any window manager on new X server;
                       image contains its own desktop and/or window manager
 -x                    use Xpra or Xephir to show docker applications on 
                       display :0 instead of switching to another tty
                       (automated decision depending on option '-d, --desktop')
 -a, --xpra            use Xpra to show application windows on display :0
                       (needs packages 'xpra' and 'xvfb' to be installed)
 -y, --xephyr          use Xephyr to show desktops in a window on display :0
                       (needs package 'xephyr' to be installed)
 -c, --clipboard       share clipboard between X servers (Xpra only) (clipboard
                       sharing to Xephyr and X11: text only) 
 -f, --fullscreen      run Xephyr in fullscreen mode
 -z, --size XxY        set Xephyr screen size (f.e. 800x600 )
 -r, --resizeable      make Xephyr window resizeable (Note: some window
                       managers/desktops won't like this and may misbehave)
 --glamor              enable Xephyr glamor 2D acceleration
 -e, --exe             execute host application on new X server (no docker)
 -u, --hostuser        create a user in the container similar to the host user
                       (same UID, same GID, same name) (experimental)
 -o, --sudouser        same as in '--hostuser', but container user gains root
                       permissions via sudo without password
 -m, --home            share folder ~/x11docker/IMAGENAME (in home folder)
                       with created container. For use with option '--hostuser'
 --pulseaudio          enable sound with pulseaudio over tcp. Needs
                       pulseaudio to be installed on host and in image
 --gpu                 use hardware accelerated OpenGL rendering. Needs
                       mesa-utils in your image to be installed.
                       Works with core X server only. Experimental / beta
Advanced options:
 -s, --sudo            use 'sudo' to run 'su -c docker ...' (Ubuntu special)
 --starter             create starter on desktop & exit
 --no-xhost            disable any access to host X server granted by xhost
 --orphaned            check for non-removed containers and left cache files 
                       possibly owned by root and created by docker
 -p, --ps              preserve container on exit (as a default, x11docker sets
                       docker run option '--rm' to remove created container)
 --root                allow root to run x11docker. Default: No
                       (A new X server should not run as root)
 --command             only show created docker command on stdout and exit
 --cid                 show filename that contains container ID on stdout
 --cache               don't delete cache files on exit (including logs)
 -v, --verbose         be verbose
 -l, --log             show log in an xterm window on display :0
 -L, --LOG             show log in an xterm window on new display

Dependencies: depending on choosed options, x11docker needs some packages
         to be installed. It will check for them on startup and show messages 
         if some are missing. List of possibly needed packages:
         docker.io xorg wmctrl xpra xephyr xvfb xclip pulseaudio

Window manager: x11docker works fine with most common window managers.
         x11docker tries to detect your current running window manager to 
         start a new instance of it on the new display. Otherwise, choose
         one you like. Recommendations:
          * Lightweight and desktop independent:
$WM_RECOMMENDED_DESKTOP_LIGHT 
          * Heavy and desktop independent:
$WM_RECOMMENDED_DESKTOP_HEAVY
          * Lightweight, no desktop options: (if you run only X server and
            window manager, you would need an exit/logout option)
$WM_RECOMMENDED_NODESKTOP_LIGHT
          * Heavy, no desktop options:
$WM_RECOMMENDED_NODESKTOP_HEAVY
         _NOT_ recommended:
          * Known to have problems in some situations: 
$WM_UGLY
          * Known not to work at all:
$WM_BAD
"
}
license() {  # --license: show license (MIT)
echo 'MIT License

Copyright (c) 2015,2016 Martin Viereck

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.'
}
{ #### part: variable descriptions and default settings
CONFIGFOLDER=$HOME/.config/x11docker            # define config file folder. Will be changed to path of subfolder
#CACHEFOLDER=/tmp/x11docker                      # define cache folder to store temporary files
CACHEFOLDER=$HOME/.cache/x11docker              # define cache folder to store temporary files
X11DOCKERRC=$CONFIGFOLDER/x11dockerrc           # config file to preset options
XTERM='xterm -xrm XTerm*selectToClipboard:true' # command to run xterm with clipboard support

X11DOCKERMODE=""                                # can be either "onlyX", "run" or "exe", depends on options
DOCKERARGS=""                                   # arguments to submit to docker
DOCKEROPTIONS=""                                # options for docker without image name/image args
X11DOCKERARGS="$*"                              # arguments for x11docker without arguments for docker
ARGUMENT=""                                     # variable to step through arguments
IMAGENAME=""                                    # name of image to run
IMAGECOMMAND=""                                 # name of image [+ commands+args]
CONTAINERNAME=""                                # name of container, set by x11docker
DOCKERUSER=""                                   # username of docker user

DOCKERIP=""                                     # IP adress of docker interface
DOCKERFULLIP=""                                 # IP adress of docker interface including suffix /16
DOCKERPID="123454321"                           # process ID (PID) of docker instance. set a dummy here
XINITRC=xinitrc                                 # file to store xinitrc commands
XINITLOGFILE=xinit.log                          # file to log output of X server
XTERMRC=xtermrc                                 # file to store xtermrc commands
XTERMLOGFILE=xterm.log                          # file to log output of xterm
DOCKERLOGFILE=docker.log                        # file to log output of docker
DOCKERPIDFILE=docker.pid                        # file to store process ID of docker
CIDFILE=containerID                             # file to store container ID number
BGPIDFILE=bgpids                                # file to store PIDS and names of background processes that shut be killed on exit

XSERVER="X11"                                   # X server to use ( one of X11 | XPRA | XEPHIR)
XEXTENSIONS=""                                  # X extensions to enable on all x11docker X servers
STARTXAUTHORITY=$XAUTHORITY                     # store Environment variable pointing to X authority cookies
if [ -z "$STARTXAUTHORITY" ] ; then STARTXAUTHORITY=$HOME/.Xauthority ; fi
STARTDISPLAY=$DISPLAY                           # store Environment variable containing name of current display
NEWDISPLAY=""                                   # new display for new X server
XSERVERCOOKIE=Xservercookie                     # file to store new X server cookies
XCLIENTCOOKIE=Xclientcookie                     # file to store new X client cookies
#NEWXLOCK=""                                     # .Xn-lock - exists for running X server with socket n
NEWXSOCKET=""                                   # New X socket (unused)
NEWXVT=""                                       # Virtual console to use for core new X server (>7)

# options for different X servers
XPRAARGS=""
XEPHYRARGS=""

# special for Xpra:
XPRASERVERLOGFILE=xpraserver.log                # logfile for Xpra server
ZEIT=""                                         # for counting time until Xpra server is ready

# special for Xephyr
WINDOWTITLE=""                                  # window title for Xephyr. Will be filled while parsing options
# Get screen size for use with Xephyr and as frame buffr size for xvfb/xpra
XAXIS=$(xrandr --current | grep '*' | tail -1 | awk '{print $1}' | cut -d 'x' -f1)
YAXIS=$(xrandr --current | grep '*' | tail -1 | awk '{print $1}' | cut -d 'x' -f2)
XEPHYRSIZE="-screen $(($XAXIS-100))x$(($YAXIS-100))"   # option '-z, --size' can change this value. otherwise, a nearly maximized window size is set here
XEPHYRFULLSCREEN="no"                           # option '-f, --fullscreen': use fullscreen mode (Xephyr only)
XEPHYRGLAMOR="no"                                 # option '--glamor': enable Xephyr glamor 2D acceleration

# variables depending on options
WINDOWMANAGER=""                                # option '-w, --wm': window manager to use
DESKTOPIMAGE="no"                               # option '-d, --desktop': if "yes", run desktop environment instead of single application
AUTOCHOOSESERVER="no"                           # option '-x': automated choosing server
SHARECLIPBOARD="no"                             # option '-c, --clipboard' can allow clipboard sharing for Xpra
SHARECLIPBOARDSCRIPT="clipboard.bash"           #    "              "      script used for text sharing to Xephyr/X11 
#
ADDHOSTUSER="no"                                # option '-u, --hostuser': try to add user to container with same UID and GID as host user
ADDSUDOUSER="no"                                # option '-o, --sudouser': same as '-u, --hostuser', but created user gains root access via sudo without password
CREATEUSERSCRIPT=createuser                     #   "          "         : file to store commands to create container user
ADDUSERHOME="no"                                # option '-m, --home': share a folder ~/.local/share/x11docker/IMAGENAME with created container
ADDUSERHOMEFOLDER=""                            #   "        "   : path to shared folder
BENUTZER=$USER                                  # name of user to simulate in container
#
PULSE_PORT=""                                   # option '--pulseaudio': pulseaudio tcp  to use
PULSE_MODULE_ID=""                              #   "                    number of customized pulseaudio tcp module, output of pactl
#
ORPHANEDCHECK="no"                              # option '--orphaned': check for non-removed containers and maybe root-owned files in cache
CREATEDESKTOPSTARTER="no"                       # option '--starter': create desktop starter and exit yes/no
ALLOWROOT="no"                                  # option '--root': allow root to run x11docker
ONLYSHOWCOMMAND="no"                            # option '-c, --command': if not empty, only show docker command and exit
GETROOT="su -c"                                 # option '-s, --sudo' will add 'sudo' to command to get root privileges.
SHOWCIDFILENAME="no"                            # option '--cid': if 'yes', show filename of file containing container ID 
VERBOSE=""                                      # options '-v, --verbose': if "yes", be verbose
SHOWLOG="no"                                    # option '-l, --log': show log in an xterm window on display :0
SHOWLOGNEWDISPLAY="no"                          # similar to '--log', but on new display
PRESERVECACHEFILES="no"                         # option '--cache': preserve cache files instead of removing them on exit
PRESERVECONTAINER="no"                          # option '-p, --ps': if yes, preserve container instead of removing it with 'docker run --rm'
GPU="no"                                        # option '--gpu': Use hardware accelerated OpenGL
#
NO_XHOST="no"                                   # option '--no-xhost': if yes, disable all X server access granted by xhost
# strings collecting pids of background jobs to be killed before exiting
JOBSTOKILL=""                                   # collections of job pids to kill before exit of script (for 'tail'/option '-V, --VERBOSE')
XINITJOBSTOKILL=""                              # collection of job pids to kill at end of xinitrc

# Window manager variables
WM_NAME=""                                      # base name of window manager
WMCTRL_IS_INSTALLED=""                          # wmctrl is installed yes/no
#
# these window managers are known to work well with x11docker (alphabetical order)(excluding $WM_NOT_RECOMMENDED and $WM_UGLY):
WM_GOOD="amiwm blackbox cinnamon compiz ctwm enlightenment fluxbox flwm fvwm"
WM_GOOD="$WM_GOOD jwm kwin lxsession mate-session mate-wm marco metacity muffin mutter notion olwm olvwm openbox ororobus pekwm"
WM_GOOD="$WM_GOOD sawfish twm wmaker w9wm xfwm4"
# these wm's are recommended, lightweight AND desktop independent. best first:
WM_RECOMMENDED_DESKTOP_LIGHT="flwm blackbox fluxbox jwm mwm wmaker afterstep amiwm fvwm ctwm pekwm olwm olvwm openbox" 
# these wm's are recommended, heavy AND desktop independent. best first:
WM_RECOMMENDED_DESKTOP_HEAVY="mate-session lxsession enlightenment"
# these wm's are recommended and lightweight, but cannot show desktop options. best first:
WM_RECOMMENDED_NODESKTOP_LIGHT="sawfish xfwm4 metacity mutter"
# these wm's are recommended and heavy, but cannot show desktop options (especially exiting themselves). best first:
WM_RECOMMENDED_NODESKTOP_HEAVY="kwin compiz cinnamon gnome-shell"
# these wm's are not really useful (please don't hit me) (best first):
WM_NOT_RECOMMENDED="awesome evilwm herbstluftwm i3 lwm matchbox miwm spectrwm subtle windowlab wmii wm2"
# these wm's cannot be autodetected by wmctrl if they are already running
WM_NODETECT="aewm aewm++ afterstep awesome ctwm mwm miwm olwm olvwm sapphire windowlab wm2 w9wm"
# these wm's can cause problems (they can be beautiful, though):
WM_UGLY="icewm sapphire aewm aewm++"
# these wm's doesn't work:
WM_BAD="clfswm tinywm tritium"
# List of all working window managers, recommended first: (excluding $WM_BAD)
WM_ALL="$WM_RECOMMENDED_DESKTOP_LIGHT $WM_RECOMMENDED_NODESKTOP_LIGHT $WM_RECOMMENDED_DESKTOP_HEAVY $WM_RECOMMENDED_NODESKTOP_HEAVY $WM_GOOD $WM_UGLY"
}
error() {    # show error messages on stderr and exit
    echo "x11docker ERROR: $*" >&2
    echo "Type 'x11docker --help' for usage information" >&2
    echo "For debugging, enable option '-v, --verbose' and run x11docker in terminal" >&2
    echo "and / or enable option '--cache' and see logfiles in" >&2 
    echo "$CACHEFOLDER" >&2
    echo "" >&2
    exit 1
}
warning() {  # show warning message
    echo "x11docker WARNING: $*" >&2
    echo "" >&2
}
verbose() {  # show verbose messages
    echo "x11docker: $*"
    echo ""
}
storepid () { # store pids and names in file $BGPIDFILE
    # store PID and process name of background processes in file
    # $1 should be PID, $2 should be name of process
    # for use on exit / with trap to clean up with background processes
    # normally, they should be terminated via $PIDSTOKILL/$XINITPIDSTOKILL
    # this subroutine has a twin in xinitrc
    echo $1 $2 >> $BGPIDFILE
}
killbgpids () { # kill background processes listet in $BGPIDFILE
    # check for possible remaining background processes stored in $BGPIDFILE
    # double check with PID and name; kill if process is still running
    # jobs in $JOBSTOKILL and $XINITPIDSTOKILL should already be killed, but will be checked here, too
    LINE=""  # line of $BGPIDFILE
    PID=""   # PID to look for
    NAME=""  # name matching to PID
    DOCKERPID=""
    ZEIT=""
    COUNT=""
    #
    while read LINE 
    do 
        PID=$(echo $LINE | awk '{print $1}')
        NAME=$(echo $LINE | awk '{print $2}')
        if [ -n "$(pgrep $NAME | grep $PID)" ] ; then
            warning "Found remaining background process.
  Will send signal TERM to process $LINE"
            kill $PID
            if [ "$NAME" = "docker" ] ; then DOCKERPID=$PID ; fi
        fi
    done < $BGPIDFILE
    #
    # if x11docker was interrupted, maybe docker is still running the
    # container. This can cause some issues; especially, if the cache
    # is deleted, but not the container, docker will recreate mounted
    # files 'Xcookie' and 'createuser' as folders belonging to root.
    #
    if [ -n "$DOCKERPID" ] ; then
        warning "Found remaining docker process. Most probably the
  X session was not closed in a clean way. Could not send TERM signal because 
  docker runs as root. Will wait up to 10 seconds for docker to finish."
        ZEIT=`date +%s`
        while [ -n "$(pgrep docker | grep $DOCKERPID)" ] ; do
            echo "waiting for docker to terminate ..."
            sleep 0.5
            COUNT=$(echo "`date +%s` - $ZEIT" | bc)
            if [ 10 -lt $COUNT ] ; then break ; fi
        done
        if [ -n "$(pgrep docker | grep $DOCKERPID)" ] ; then
            warning "docker didn't terminate as it should. Will not clean
  cache to avoid file permission problems. You should stop docker and remove
  the new container with command:
docker stop `cat $CIDFILE` && docker rm `cat $CIDFILE`"
            PRESERVECACHEFILES="yes"
        fi
    fi
}
finish() { # trap routine, clean up background processes and cache
    #
    # kill registered background processes
    for ARGUMENT in $PIDSTOKILL ; do kill $ARGUMENT ; done  # clean up
    #
    # kill possible remaining background processes (f.e. on interrupt)
    if [ -f "$BGPIDFILE" ] ; then killbgpids ; fi
    #
    # option '--cache': [don't] remove cache files
    if [ "$PRESERVECACHEFILES" = "no" ] ; then 
        if [ "X`echo $NEWDISPLAY | tr -d :`" = "$(basename $CACHEFOLDER)" ] ; then
            rm -f -R $CACHEFOLDER
        fi
    fi
}
no_xhost() { # remove any access to X server granted by xhost
  xhost | tail -n +2  /dev/stdin | while read LINE ; do  # read all but the first line (header)
    xhost -$LINE                                         # disable every entry
  done
  xhost -                                                # enable access control
}
orphaned() { # option --orphaned : check for non-removed containers and left cache files possibly owned by root and created by docker
  echo "x11docker will check for orphaned containers from earlier sessions. 
    This can happen if docker was not closed successfully. If this is the case,
    and option --home was chosen, docker creates missing shared files as 
    folders owned by root in your home cache folder. This is annoying. x11docker 
    will try to find such containers and delete all x11docker cache files.
    Caution: any currently running x11docker sessions will be terminated, too.
    Please type in your password to get a current list of existing containers:"
  MATCHCONTAINERS=""
  MATCHFOLDERS=""
  cd $CACHEFOLDER
  while read -r LINE ; do
    MATCHCONTAINERS="$MATCHCONTAINERS $(echo $LINE | cut -d ' ' -f1)"
#    FOLDER="$(echo $LINE | rev | cut -d_ -f2 | rev)"
#    if [ -d "$FOLDER" ] ; then MATCHFOLDERS="$MATCHFOLDERS $FOLDER" ; fi
  done < <($GETROOT 'docker ps -a' | grep "x11docker_")
  MATCHFOLDERS=$(echo $(find $CACHEFOLDER -mindepth 1 -maxdepth 1))
  if [ -z "$MATCHCONTAINERS" ] && [ -z "$MATCHFOLDERS" ] ; then echo "No orphaned containers or cache files found. good luck!"
  else
    echo "Found orphaned containers: $MATCHCONTAINERS"
    echo "Found orphaned folders in $CACHEFOLDER: $MATCHFOLDERS"
    echo "Type in your password to remove orphaned containers and folders:"
    if [ -n "$MATCHCONTAINERS" ] && [ -n "$MATCHFOLDERS" ] ; then
      echo $GETROOT "'docker rm -f $MATCHCONTAINERS ; rm -R -v $MATCHFOLDERS'"
      eval $GETROOT "'docker rm -f $MATCHCONTAINERS ; rm -R -v $MATCHFOLDERS'"
    fi
    if [ -n "$MATCHCONTAINERS" ] && [ -z "$MATCHFOLDERS" ] ; then
      echo $GETROOT "'docker rm -f $MATCHCONTAINERS'"
      eval $GETROOT "'docker rm -f $MATCHCONTAINERS'"
    fi
    if [ -z "$MATCHCONTAINERS" ] && [ -n "$MATCHFOLDERS" ] ; then
      echo $GETROOT "'rm -R -v $MATCHFOLDERS'"
      eval $GETROOT "'rm -R -v $MATCHFOLDERS'"
    fi
  fi
}
xdparser() { # parse args for x11docker
    #
    SHORT="hw:dxXayrz:scuomfvVeplL"
    LONG="help,license,licence,wm:,desktop,command,x,X,xpra,Xpra,xephyr,Xephyr,sudo,root,clipboard,hostuser,sudouser,home,fullscreen,pulseaudio,gpu,verbose,orphaned,exe,cid,cache,ps,resizeable,size:,glamor,starter,log,LOG,no-xhost"
    LONG="$LONG,devel:,xhost,virtualgl,privileged" ### developer options, not for regular use
    PARSED=`getopt --options $SHORT --longoptions $LONG --name "$0" -- "$@"`
    if [ "$?" != "0" ] ; then error "Error while parsing options. See 'x11docker --help' for vaild options." ; fi
    eval set -- "$PARSED"
    if [[ $? != 0 ]]; then error $? ; fi
    while [ -n "$1" ] ; do
        case $1 in
            -h|--help) usage && exit 0                      # show help/usage and exit
            ;;
            --license|--licence) license && exit 0                    # show MIT license and exit
            ;;
            -w|--wm) WINDOWMANAGER=$2 && shift              # custom window manager
            ;;
            -d|--desktop) DESKTOPIMAGE="yes"                # desktop environment or window manager in image; don't run own window manager
            ;;
            --command) ONLYSHOWCOMMAND="yes"                # only show created docker command and exit
            ;;
            -s|--sudo) GETROOT="sudo $GETROOT"              # use sudo to run 'su -c docker ...'
            ;;
            -x|-X|--x|--X) AUTOCHOOSESERVER="yes"           # use xpra or Xephir instead of switchung to new tty with X (depending on option --desktop) 
                                                            # autodect best way to run
            ;;
            -a|--xpra|--Xpra) XSERVER="XPRA"                # use Xpra instead of X
            ;;
            -y|--xephyr|--Xephyr) XSERVER="XEPHYR"          # use Xephyr instead of X
            ;;
            -c|--clipboard) SHARECLIPBOARD="yes"            # share host clipboard with dockered applications (Xpra only)
            ;;
            -f|--fullscreen) XEPHYRFULLSCREEN="yes"               # fullscreen mode for Xephyr and
            ;;
            -z|--size) XEPHYRSIZE="-screen $2" && shift     # set screen size for Xephyr
            ;;
            -r|--resizeable) XEPHYRRESIZE="yes"             # make Xephyr window resizeable
            ;;
            --glamor) XEPHYRGLAMOR="yes"                    # enable glamor 2D acceleration in Xephyr
            ;;
            --pulseaudio) PULSEAUDIO="yes"                  # enable pulseaudio connection / sound support over tcp
            ;;
            --gpu) GPU="yes"                                # use hardware accelerated OpenGL
            ;;
            -e|--exe) X11DOCKERMODE="exe"                   # execute application from host instead of running docker image
            ;;
            --root) ALLOWROOT="yes"                         # allow x11docker to be run as root
            ;;
            -u|--hostuser) ADDHOSTUSER="yes"                # create user similar to host user in created container
            ;;
            -o|--sudouser) ADDHOSTUSER="yes"                # same as '--hostuser', but with root rights via sudo without password
                            ADDSUDOUSER="yes"
            ;;
            -m|--home) ADDUSERHOME="yes"                    # share folder ~/x11docker/IMAGENAME with container
            ;;
            --starter) CREATEDESKTOPSTARTER="yes"           # create desktop starter and exit
            ;;
            -p|--ps) PRESERVECONTAINER="yes"                # presreve container instead of removing it with 'docker run --rm'
            ;;
            --cid) SHOWCIDFILENAME="yes"                    # show filename of file containing container ID
            ;;
            --cache) PRESERVECACHEFILES="yes"               # don't remove cache files on exit
            ;;
            -v|--verbose) VERBOSE="yes"                     # be verbose
            ;;
            -l|--log) SHOWLOG="yes"                         # Show logs in an xterm window on display :0
            ;;
            -L|--LOG) SHOWLOGNEWDISPLAY="yes"               # Show logs in an xterm window on new display
            ;;
            --orphaned) ORPHANEDCHECK="yes"                # check for orphaned containers and files owned by root, created by docker)
            ;;
            --no-xhost) NO_XHOST="yes"                      # disable any access granted by xhost
            ;;
            #####some developer options, not for regular use, can change any time
            --devel) DEVMODE="$2" && shift  && echo "DEVMODE $DEVMODE"  # non-documented develepor option. effect can change.
            ;;
            --virtualgl) VGLRUN="yes"
            ;;
            --xhost) XHOST="+"
            ;;
            --privileged) PRIVILEGED="yes"
            ;;
            --) shift                                       # arguments to submit to docker (or host executable)
                if [ "$X11DOCKERMODE" != "exe" ] ; then X11DOCKERMODE="run" ; fi             # will run image, if not already changed to '--exe'
                while [ -n "$1" ] ; do                                                       # get all options for docker after '--'
                    DOCKERARGS="$DOCKERARGS $1"
                    if [ "-" != "$(echo $1 | cut -c 1)" ] ; then                             # (ignore -options)
                        WINDOWTITLE="$WINDOWTITLE""_$1"                                      # create window title for Xephyr
                        if [ -z "$IMAGENAME" ] ; then IMAGENAME="$1" ; fi                    # get name of image
                    fi
                    if [ -n "$WINDOWTITLE" ] ; then IMAGECOMMAND="$IMAGECOMMAND $1" ;fi      # get image command without 'docker run' options
                    if [ -z "$IMAGENAME" ] ; then DOCKEROPTIONS="$DOCKEROPTIONS $1" ; fi     # options for 'docker run' without imagename/image args
                    shift
                done
                if [ -n "$IMAGECOMMAND" ] ; then
                    IMAGECOMMAND=`echo $IMAGECOMMAND | cut -s -d " " -f 2- `                    # remove image name from image command
                fi
                if [ -z "$(eval echo $DOCKERARGS)" ] ; then X11DOCKERMODE="onlyX" ; fi       # if arguments are empty, then only run X server with window manager
            ;;
            *) error "error while parsing $1"              # should never happen(tm)
            ;;
        esac  
        shift
    done
    echo $DOCKEROPTIONS
}
configwindowmanager() { # set some window manager configs, if needed
    #
    # needs $WM_NAME to be set, will change $WINDOWMANAGER
    #
    case $WM_NAME in
        cinnamon|cinnamon-session) WINDOWMANAGER="cinnamon-session -f"
                                   WM_NAME="cinnamon"
            ;;
        compiz) # set minmal config to have useable window decoration and can move windows
            if [ ! -e "$HOME/.config/compiz-1/compizconfig/Default.ini" ] ; then
                mkdir -p "$HOME/.config/compiz-1/compizconfig"
                echo "[core]
s0_active_plugins = core;composite;opengl;decor;resize;move;
" > "$HOME/.config/compiz-1/compizconfig/Default.ini"
            fi
            ;;
        enlightenment|e17|e16|e19) WINDOWMANAGER="enlightenment_start"
                               WM_NAME="enlightenment"
            ;;
        gnome|gnome-shell|gnome-session) # crashes without option '--sm-disable' on ubuntu 14.04
            WINDOWMANAGER="gnome-shell --sm-disable"
            WM_NAME="gnome-shell"
            ;;
        matchbox) WINDOWMANAGER="matchbox-window-manager"
            ;;
        mate|mate-session) WINDOWMANAGER="mate-session -f"
                           WM_NAME="mate"
            ;;
        marco) WINDOWMANAGER="marco --sm-disable"
            if [ -z "`command -v mate-session`" ] ; then
                warning "Found window manager marco. It seems that not all 
  dependencies are installed. Will try to search for another window manager"
                WINDOWMANAGER="lookfornewwindowmanager"
            fi
            ;;
        mate-wm) WINDOWMANAGER="marco --sm-disable"
            ;;
        muffin) WINDOWMANAGER="muffin --sm-disable"
            if [ -z "`command -v cinnamon`" ] ; then
                warning "Found window manager muffin. It seems that not all 
  dependencies are installed. Will try to search for another window manager"
                WINDOWMANAGER="lookfornewwindowmanager"
            fi
            ;;
        tinywm)
            error "Window manager $WINDOWMANAGER is not working well, sorry.
  Please choose another window manager with option '-w, --wm'.
  x11docker will try to find another one on your system."
            WINDOWMANAGER="lookfornewwindowmanager"
            ;;
        openbox) # disable session management of openbox, otherwise it could shut down your main session, too
            WINDOWMANAGER="openbox --sm-disable"
            ;;
    esac
    #
    # special check: normally Xephyr runs without window manager
    if [ "$XSERVER" = "XEPHYR" ] && [ "$XEPHYRFULLSCREEN" = "no" ] ; then
        case $WM_NAME in
        gnome-shell|cinnamon)
            warning "$WM_NAME can have problems in Xephyr, except running in
  fullscreen mode (option '-f, --fullscreen'). Will try to to find another
  window manager"
            WINDOWMANAGER="lookfornewwindowmanager"
        esac
    fi
}

{ #### part: some init (parsing, checking permissions)
  trap finish EXIT

  ## parse x11dockerrc, if exists
  #
  if [ -e "$X11DOCKERRC" ] ; then xdparser $(tail -1 $X11DOCKERRC) ;fi
  
  ## parse command line options for x11docker
  #
  xdparser $X11DOCKERARGS

  ## check if docker is installed
  #
  if [ "$X11DOCKERMODE" = "run" ] ; then
    command -v "docker" >/dev/null 2>&1 || { error "could not find docker.
  You need it to run docker images. Please install docker with command:
  apt-get install docker.io" ; }
  fi

  ## check if script runs as root, if yes, show error & exit
  #
  if [ "$ALLOWROOT" = "no" ] ; then   # option '-r,--root': if "yes", allow root to run x11docker
    if [ "0" = "$(id -u)" ] ; then
        error "x11docker should not run as root. Every child process of 
  the new X server would get root privileges, too. To run docker, you will be
  prompted for your root password only for this one command.
  On systems without a root password, like Ubuntu, choose option '-s, --sudo'
  If you want to allow root to run x11docker, use option '--root'"
    fi
  else
    if [ "0" = "$(id -u)" ] ; then GETROOT="" ; fi   # if running as root and it is allowed, then disable password prompt
  fi

  ## if user is member of group docker, then avoid password prompt
  #
  if [ -n "`id | grep docker`" ] ; then GETROOT="" ; fi

  ## if desktop starter should be created, check if xdg-user-dir is installed
  #
  if [ "$CREATEDESKTOPSTARTER" = "yes" ] ; then
    command -v "xdg-user-dir" >/dev/null 2>&1 || { error "could not find xdg-user-dir.
  x11docker needs it to create a desktop starter. Please install xdg-utils with
  command:
  apt-get install xdg-utils" ; }
  fi
  
  ## option --orphaned : check for non-removed containers and left cache files possibly owned by root and created by docker
  if [ "$ORPHANEDCHECK" = "yes" ] ; then 
    orphaned
    exit
  fi
  
  ## option '--pulseaudio': find a free tcp port
  if [ "$PULSEAUDIO" = "yes" ] ; then
    read LOWERPORT UPPERPORT < /proc/sys/net/ipv4/ip_local_port_range
    while : ; do
      PULSE_PORT="`shuf -i $LOWERPORT-$UPPERPORT -n 1`"
      ss -lpn | grep -q ":$PULSE_PORT " || break
    done
  fi
}

{ #### check X server
  ## option '-x, --X': show on display :0 instead of switching to another tty
  #  check if either xpra or Xephir should be used for this job
  #
  if [ "$AUTOCHOOSESERVER" = "yes" ] ; then
    if [ "$DESKTOPIMAGE" = "no" ] ; then
        XSERVER="XPRA"      # use xpra for single applications
    else
        XSERVER="XEPHYR"    # use Xephyr for desktop environments
    fi
  fi

  ## check if choosed X server is installed
  #
  if [ "$XSERVER" = "XPRA" ] ; then                                 # check Xpra
    command -v "/usr/bin/xpra" >/dev/null 2>&1 || { warning "could not find executable '/usr/bin/xpra'. 
  Also needed: 'xvfb' Try 'apt-get install xpra xvfb' to install Xpra and Xvfb.
  Fallback: x11docker will try to use Xephyr"
    XSERVER="XEPHYR"
    }
  fi
  if [ "$XSERVER" = "XEPHYR" ] ; then                               # check Xephyr
    command -v "/usr/bin/Xephyr" >/dev/null 2>&1 || { warning "could not find executable '/usr/bin/Xephyr'. 
  Try 'apt-get install xephyr' to install Xephyr.
  Fallback: x11docker will try to use X11"
    XSERVER="X11"
    }
  fi
  if [ "$XSERVER" = "XPRA" ] ; then    # check Xvfb
    command -v "/usr/bin/Xvfb" >/dev/null 2>&1 || { warning "could not find executable '/usr/bin/Xvfb'. 
  Try 'apt-get install xvfb' to install Xvfb. Need Xvfb to run Xpra.
  Fallback: x11docker will try to use X11"
    XSERVER="X11"
    }
  fi
  if [ "$XSERVER" = "X11" ] ; then                                 # check X
    command -v "/usr/bin/X" >/dev/null 2>&1 || { error "Could not find executable '/usr/bin/X'. 
  Try 'apt-get install xorg' to install X server."
    }
    # if x11docker is running from within an X server, check if user is allowed to run a new X server
    if [ -z "`grep "allowed_users=anybody" </etc/X11/Xwrapper.config`" ] && [ -n "$STARTDISPLAY" ] ; then
            error "You are not allowed to start a new X server.
  To start a new X server from within an already running X session, you need
  to run 'dpkg-reconfigure x11-common' and choose option 'anybody'.
  Otherwise, you can switch to tty1 with <STRG><ALT><F1> and start x11docker
  there. 
  (As a default configuration of X, only root or console users can start a 
  new X server)
  Otherwise, you can use Xpra or Xephyr (see options '--xpra' and '--xephyr')."
    fi
  fi

  ## check for already running X server, if $XSERVER is not "X11"
  # Xpra and Xephyr need an already running X server for their output window(s)
  # (check could be better, not only for standard :0)
  #
  if [ "$XSERVER" != "X11" ] && [ -z "$STARTDISPLAY" ] ; then
    if [ -S "/tmp/.X11-unix/X0" ] ; then
        STARTDISPLAY=":0"
        echo "NOTE: $XSERVER will show its content on display $STARTDISPLAY"
    else
        error "No X server found on display :0. You cannot run $XSERVER 
  without an already running X server. Exiting."
    fi
  fi
}

{ #### part: choose and check window manager
  if [ "$DESKTOPIMAGE" = "no" ] && [ ! "$XSERVER" = "XPRA" ] ; then  # check only if a window manager is needed
    #
    ## try to find out current window manager to use it for x11docker (i.e., run a new instance of it)
    #
    if [ -n "$(command -v 'wmctrl')" ] ; then WMCTRL_IS_INSTALLED="yes" ; else WMCTRL_IS_INSTALLED="no" ; fi
    #
    if [ -z "$WINDOWMANAGER" ] && [ "$WMCTRL_IS_INSTALLED" = "yes" ] ; then  # option '-w, --wm': maybe a window manager is already set
        WINDOWMANAGER=`wmctrl -m | grep "PID" | awk '{print $2}' `                 # at first get pid
        if [ -e "/proc/$WINDOWMANAGER" ] ; then                                    # check if pid is valid
            WINDOWMANAGER=`ls -l "/proc/$WINDOWMANAGER/exe" | awk '{print $11}'`   # if yes, then get /path/executable
        else                                                                       # otherwise, try unsecure way over name
            WINDOWMANAGER=`wmctrl -m | grep "Name" | awk '{print $2}' | tr '[:upper:]' '[:lower:]'`              #| awk '{print $1}'`
        fi
    fi
    #
    if [ -n "$WINDOWMANAGER" ] ; then
        # get base name without options of window manager
        WM_NAME=$(basename $WINDOWMANAGER | awk '{print $1}')
        # check window manager, set configs, if needed
        configwindowmanager
    fi
    #
    ## if no executable window manager is found, then search for another one
    #
    if [ -z "$(command -v $WINDOWMANAGER)" ] ; then
        for ARGUMENT in $WM_ALL ; do
            WINDOWMANAGER=`command -v $ARGUMENT`
            if [ -n "$WINDOWMANAGER" ] ; then break ; fi
        done
    fi
    #
    ## again, get base name without options of window manager
    WM_NAME=$(basename $WINDOWMANAGER | awk '{print $1}')
    # again, check window manager, set configs, if needed
    configwindowmanager
    #
    ## check if window manager is executable now; if not, show error & exit
    #
    if [ -z "$(command -v $WINDOWMANAGER)" ] ; then 
        error "could not find any executable window manager. 
  Please choose a window manager with option '-w, --wm'
  Type 'x11docker --help' to get a list of recommended window managers."
    fi
    #
  else
    WINDOWMANAGER=""     # if XPRA works as window manager, or image contains its own wm/DE, then x11docker doesn't need one
  fi
}

{ #### part: check free display, create cache folders and rename cache files
  ## create main cache folder and config folder, if not already present
  #
  mkdir -p $CACHEFOLDER
  mkdir -p $CONFIGFOLDER

  ## Look for next free display and change some display specific variables
  #
  case $XSERVER in                 # set initial value for searching
    X11) NEWDISPLAY="0" ;;       # low number for X displays
    XPRA) NEWDISPLAY="100" ;;    # high numbers fpr Xpra displays
    XEPHYR) NEWDISPLAY="200" ;;  # higher number for Xephyr displays
  esac
  #
  while [ -e "/tmp/.X11-unix/X$NEWDISPLAY" ]  || [ -e "$CACHEFOLDER/X$NEWDISPLAY" ] ; do   # search unused X socket, overhop already used cache numbers
    NEWDISPLAY=$(($NEWDISPLAY + 1))
  done
  #
  CACHEFOLDER="$CACHEFOLDER/X$NEWDISPLAY"                    # set name of cache subfolder
  #
  XINITRC="$CACHEFOLDER/$XINITRC"
  XINITLOGFILE="$CACHEFOLDER/$XINITLOGFILE"
  XTERMRC="$CACHEFOLDER/$XTERMRC"
  XTERMLOGFILE="$CACHEFOLDER/$XTERMLOGFILE"
  DOCKERLOGFILE="$CACHEFOLDER/$DOCKERLOGFILE"
  DOCKERPIDFILE="$CACHEFOLDER/$DOCKERPIDFILE"
  XSERVERCOOKIE="$CACHEFOLDER/$XSERVERCOOKIE"
  XCLIENTCOOKIE="$CACHEFOLDER/$XCLIENTCOOKIE"
  XPRASERVERLOGFILE="$CACHEFOLDER/$XPRASERVERLOGFILE"
  XCOMMANDFILE="$CACHEFOLDER/$XCOMMANDFILE"
  CIDFILE="$CACHEFOLDER/$CIDFILE"
  BGPIDFILE="$CACHEFOLDER/$BGPIDFILE"
  CREATEUSERSCRIPT="$CACHEFOLDER/$CREATEUSERSCRIPT"
  SHARECLIPBOARDSCRIPT="$CACHEFOLDER/$SHARECLIPBOARDSCRIPT"
  NEWXSOCKET="/tmp/.X11-unix/X$NEWDISPLAY"
  #NEWXLOCK="/tmp/.X$NEWDISPLAY-lock"
  NEWXVT="vt$[7+$NEWDISPLAY]"
  #
  NEWDISPLAY=":$NEWDISPLAY"                                  # finally: add ':' to $NEWDISPLAY


  ## Get inet Adress of docker0 interface and
  #  set $TCPDISPLAY (display number for dockered applications, connected to X over tcp)
  #
  DOCKERFULLIP=`ip -4 -o a | grep docker0 | awk '{print $4}'`
  DOCKERIP=`echo $DOCKERFULLIP | cut -d/ -f1`
  TCPDISPLAY=$DOCKERIP$NEWDISPLAY

  ## create and clean cache subfolder
  #
  mkdir -p $CACHEFOLDER
  rm -f -R $CACHEFOLDER/*
}

{ #### part: create command to run docker

  case $X11DOCKERMODE in
    run)
        COMMAND='docker run'
        if [ -n "$PRIVILEGED" ] ; then COMMAND="$COMMAND --privileged" ; fi ### developer option --privileged
        case $DEVMODE in
          "")
            case $GPU in
            yes)
              COMMAND="$COMMAND -e DISPLAY=$NEWDISPLAY"
              COMMAND="$COMMAND -v $NEWXSOCKET:$NEWXSOCKET:ro"                               # share x socket
              ;;
            no)
              COMMAND="$COMMAND -e DISPLAY=$TCPDISPLAY"                                   # display over tcp 
              ;;
            esac
            ;;
          "force-tcp")
            COMMAND="$COMMAND -e DISPLAY=$TCPDISPLAY"                                   # display over tcp 
            ;;
          "force-xsocket")
            COMMAND="$COMMAND -e DISPLAY=$NEWDISPLAY"
            COMMAND="$COMMAND -v $NEWXSOCKET:$NEWXSOCKET:ro"                               # share x socket
            ;;
        esac
        
        COMMAND="$COMMAND -v $XCLIENTCOOKIE:/Xcookie:ro -e XAUTHORITY=/Xcookie"    # share new X authentication cookie file
        COMMAND="$COMMAND --cidfile=$CIDFILE"                                      # write container id in file $CIDFILE
        COMMAND="$COMMAND --name=x11docker_X$(echo $NEWDISPLAY | cut -b 2-)_$(mcookie | cut -c -6)"       
        if [ "$GPU" = "yes" ] ; then 
          while read -r FILE ; do
            echo $FILE
            if [ -c "$FILE" ] ; then COMMAND="$COMMAND --device=$FILE:$FILE:rw" ; fi
          done < <(find /dev/dri)
        fi
        #COMMAND="$COMMAND --device=/dev/dri/card0:/dev/dri/card0:rw" ; fi           # share graphic card
        if [ "$PULSEAUDIO" = "yes" ] ; then COMMAND="$COMMAND -e PULSE_SERVER=tcp:$DOCKERIP:$PULSE_PORT" ; fi # provide pulseaudio server
#        COMMAND="$COMMAND -e QT_GRAPHICSSYSTEM=raster"                              # raster or native. Can influence rendering problems in qt4
#        COMMAND="$COMMAND -e QT_X11_NO_MITSHM=1"
    ;;
    exe|onlyX) COMMAND="# dontrundocker"
    ;;
  esac
  
  if [ "$VGLRUN" = "yes" ] ; then COMMAND="vglrun +v -c 0 -d $NEWDISPLAY $COMMAND" ; fi ### developer option --virtualgl

  ## option '-p, --ps': preserve container yes/no
  #
  if [ "$PRESERVECONTAINER" = "no" ] ; then COMMAND="$COMMAND --rm" ; fi

  ## option '--home': share folder ~/.local/share/x11docker/IMAGENAME with created container as its home directory
  #
  if [ "$ADDUSERHOME" = "yes" ] ; then
    # define path to shared folder and remove '/' from image name
    ADDUSERHOMEFOLDER=$HOME/.local/share/x11docker/`echo $IMAGENAME | tr / -`
    mkdir -p $ADDUSERHOMEFOLDER
    # create symbolic link in $HOME
    if [ ! -e $HOME/x11docker ] ; then ln -s $HOME/.local/share/x11docker $HOME/x11docker ; fi
    COMMAND="$COMMAND -v $ADDUSERHOMEFOLDER:/home/$BENUTZER"
  fi

  ## option '-u, --hostuser' : create container user similar to host user
  #
  if [ "$ADDHOSTUSER" = "yes" ] ; then
    DOCKERUSER=$BENUTZER
    #
    # CMD in image will be overwritten by createuser script. If none is defined on CLI, get CMD from image
    # ('docker inspect' needs root permissions. That's not nice. Have to ask for password)
    #
    if [ -z "$IMAGECOMMAND" ] ; then
        verbose "No command for image specified. Need to look for
  CMD command of docker image. Please type in your password to run 
  $GETROOT 'docker inspect --format='{{.Config.Cmd}}' $IMAGENAME'"
        IMAGECOMMAND=`$GETROOT "docker inspect --format='{{.Config.Cmd}}' $IMAGENAME"`
        IMAGECOMMAND=$(echo $IMAGECOMMAND | tr -d [])
        IMAGECOMMAND=$(echo $IMAGECOMMAND | sed 's/\/bin\/sh -c//')
        verbose "To avoid this password prompt, you can start x11docker
  next time with command:
  x11docker $X11DOCKERARGS $IMAGECOMMAND"
        X11DOCKERARGS="$X11DOCKERARGS $IMAGECOMMAND"
    fi
    #
    # create script createuser. It will also start the image with given (or extracted) command
    #
    { echo "#! /bin/bash"
      # create user
      echo "addgroup --gid `id -g $BENUTZER` $BENUTZER"
      echo "adduser --disabled-password  --uid `id -u` --gid `id -g` --gecos " '""' " --home /home/$BENUTZER $BENUTZER"
      echo "chown $BENUTZER:$BENUTZER /home/$BENUTZER"
      echo "HOME=/home/$BENUTZER"
      
      # Workaround to avoid GTK rendering errors in Xfce with shared X socket. Unclear reasons
      # echo 'rm $HOME/.config/xfce4/xfconf/xfce-perchannel-xml/xfwm4.xml'
      
      # option '--sudouser': add sudo permissions without password
      if [ "$ADDSUDOUSER" = "yes" ] ; then
          echo 'echo "%sudo ALL=(ALL) NOPASSWD:ALL"   >> /etc/sudoers'
          echo "adduser $BENUTZER sudo"
      fi
      echo "adduser $BENUTZER video" # add user to group video, needed for option --gpu
      # run image command as user:
      echo "su $BENUTZER -c '$IMAGECOMMAND'"
    } > $CREATEUSERSCRIPT
    #
    # include created script in container
    COMMAND="$COMMAND -v $CREATEUSERSCRIPT:/createuser"
    # use created script as command (CMD) to run image
    DOCKERARGS="$DOCKEROPTIONS $IMAGENAME /bin/bash /createuser"
  else
    DOCKERUSER="root"
  fi

  # add custom docker commands 
  #
  COMMAND="$COMMAND $DOCKERARGS"

  ## option '-c, --command': only show created docker command and exit
  #
  if [ "$ONLYSHOWCOMMAND" = "yes" ] ; then echo $COMMAND && exit 0 ; fi

  ## option '--cid': show filename of file that will contain container id
  #
  if [ "$SHOWCIDFILENAME" = "yes" ] ; then echo $CIDFILE ; fi
}

{ #### part: create command to start X server
  XEXTENSIONS=""
  XEXTENSIONS="$XEXTENSIONS +extension Composite +extension RANDR +extension RENDER +extension GLX +extension XVideo +extension DOUBLE-BUFFER +iglx"
  XEXTENSIONS="$XEXTENSIONS +extension X-Resource +extension SECURITY +extension MIT-SHM +extension DAMAGE"
  case $GPU in
    yes)
      XEXTENSIONS="$XEXTENSIONS -nolisten tcp"           # disable connections to X over tcp
    ;;
  esac
  XEXTENSIONS="$XEXTENSIONS -auth $XSERVERCOOKIE"    # cookie authentication
  
  ### test
  XEXTENSIONS="$XEXTENSIONS +extension XTEST"
  
  case $XSERVER in
    X11) 
         XEXTENSIONS="$XEXTENSIONS +extension XFree86-DRI +extension XFree86-DGA +extension XFree86-VidModeExtension"
         #XEXTENSIONS="$XEXTENSIONS +extension DRI +extension DRI2 +extension DRI3 +extension SGI-GLX +extension SHAPE"
         XCOMMAND="/usr/bin/X $NEWDISPLAY $NEWXVT -quiet -retro $XEXTENSIONS"
    ;;
    XPRA) # To use Xpra, Xvfb will run first. Xpra server doesn't allow tcp connections, even if it is told to do it.
        case $SHARECLIPBOARD in                                                           # option '-c, --clipboard'
            yes) XPRAARGS="--clipboard"   ;;
            no)  XPRAARGS="--no-clipboard" ;; 
        esac
        # screen size could be checked better - see xpra/xvfb/xdummy sites about this
#        XCOMMAND="/usr/bin/Xvfb $NEWDISPLAY $XEXTENSIONS -screen 0 16384x8192x24+32 -auth $XSERVERCOOKIE"
        XCOMMAND="/usr/bin/Xvfb $NEWDISPLAY $XEXTENSIONS -screen 0 ${XAXIS}x${YAXIS}x24+32"                          # command to run Xvfb for xpra

#        XVFBARGS="$XVFBARGS -config /etc/xpra/xorg.conf -verbose $XEXTENSIONS -auth=$XSERVERCOOKIE"                  # defaults for Xdummy
#        XCOMMAND="/usr/bin/Xorg $NEWDISPLAY $XVFBARGS -auth $XSERVERCOOKIE"                                          # command to run Xdummy
    ;;
    XEPHYR)
        case $XEPHYRFULLSCREEN in    # option '--fullscreen'
            yes) XEPHYRARGS="$XEPHYRARGS -fullscreen" ;;
            no) XEPHYRARGS="$XEPHYRARGS $XEPHYRSIZE" ;;
        esac
        case $XEPHYRRESIZE in        # option '--resizeable'
            yes) XEPHYRARGS="$XEPHYRARGS -resizeable" ;;
        esac
        case $XEPHYRGLAMOR in        # option '--resizeable'
            yes) XEPHYRARGS="$XEPHYRARGS -glamor" ;;
        esac
        XEPHYRARGS="$XEPHYRARGS -title XEPHYR$WINDOWTITLE"  # set window title 
        XCOMMAND="/usr/bin/Xephyr $NEWDISPLAY -retro $XEXTENSIONS $XEPHYRARGS"
    ;;
  esac
}

{ #### part: option '-c, --clipboard' create shareclipboard.bash
  #
  # use xclip to share text clipboard content between X servers.
  # xpra has its own clipboard management including image transfer
  #
  if [ "$SHARECLIPBOARD" = "yes" ] && [ ! "$XSERVER" = "XPRA" ] ; then
    if [ -z "$(command -v 'xclip')" ] ; then
        warning "Cannot share clipboard. Need package 'xclip' to be
  installed. Try installing xclip with command: 'apt-get install xclip'"
        SHARECLIPBOARD="no"
    else 
    echo '#! /bin/bash
# share clipboard between two X servers
echo "x11docker: starting clipboard service"

while true ; do
    # read content of clipboard of first X server
    XAUTHORITY='$STARTXAUTHORITY'
    D1CLIP=$(xclip -selection clipboard -o -display '$STARTDISPLAY')
    # check if clipboard of first X server has changed; if yes, send new content to second X server
    if [ ! "$CLIP" = "$D1CLIP" ] ; then
        CLIP=$D1CLIP
        xclip -selection clipboard -o -display '$STARTDISPLAY' | XAUTHORITY='$XCLIENTCOOKIE' xclip -selection clipboard -i -display '$NEWDISPLAY'
    fi

    # read content of clipboard of second X server
    XAUTHORITY='$XCLIENTCOOKIE'
    D2CLIP=$(xclip -selection clipboard -o -display '$NEWDISPLAY')
    # check if clipboard of second X server has changed; if yes, send new content to first X server
    if [ ! "$CLIP" = "$D2CLIP" ] ; then
        CLIP=$D2CLIP
        xclip -selection clipboard -o -display '$NEWDISPLAY' | XAUTHORITY='$STARTXAUTHORITY' xclip -selection clipboard -i -display '$STARTDISPLAY'
    fi
    
    if [ -z "$CLIP" ] ; then 
      CLIP=" ";
    fi

    # sleep a bit to avoid high cpu usage
    sleep 0.3
    
done
' > $SHARECLIPBOARDSCRIPT
    fi
  fi
}

{ #### part: create xinitrc
  echo "#! /bin/bash"
  echo "set -x"
  #
  # subroutine to store PIDs and process names in file $BGPIDFILE 
  #
  echo 'storepid () { echo $1 $2 >> '$BGPIDFILE' ; }'
  #
  # things to be done on display :0 : 
  #NEWDISPLAY=$TCPDISPLAY   ### test
  #
  # set X variables to :0
  echo "export DISPLAY=$STARTDISPLAY"
  echo "export XAUTHORITY=$STARTXAUTHORITY"
  #
  declare -f no_xhost # echoes no_xhost(), including it this way in xinitrc
  if [ "$NO_XHOST" = "yes" ] ; then  ## option --no-xhost: disable any access granted by xhost
    echo "no_xhost"
  fi
  if [ -n "$XHOST" ] ; then echo "xhost $XHOST" ; fi # developer option --xhost
  #
  # option '--pulseaudio': enable pulseaudio sound over tcp
  if [ "$PULSEAUDIO" = "yes" ] ; then
    # load pulseaudio tcp module, authenticated to docker ip on specified port 
    echo 'PULSE_MODULE_ID=$(pactl load-module module-native-protocol-tcp port='$PULSE_PORT' auth-ip-acl='$DOCKERFULLIP')'
  fi
  #
  # things to be done on new display: 
  #
  # set X variables to new display
  echo "export DISPLAY=$NEWDISPLAY"
  echo "export XAUTHORITY=$XCLIENTCOOKIE"
  #
  # create background color. #7F7F7F is color of xfwm4 background
  echo 'xsetroot -solid "#7F7F7F"'
  #
# disabled: using xhost +SI:localuser:username instead, avoiding tcp. Did not manage to work with cookie this way, sigh.
#  # create new XAUTHORITY cookie file 
  echo ':> '$XCLIENTCOOKIE
#  echo "xauth generate $NEWDISPLAY . untrusted"
#  echo "xauth generate $NEWDISPLAY . trusted"    # Gives X clients more access to X resources, considered to be less secure
#  echo "xauth generate $TCPDISPLAY . trusted"
  echo 'COOKIE=$(mcookie)'
  echo "xauth add $NEWDISPLAY . "'$COOKIE'
  echo "xauth add $TCPDISPLAY . "'$COOKIE'
  echo "cp $XCLIENTCOOKIE $XSERVERCOOKIE"
  echo "xauth list"
  #
  # start window manager, if defined
  if [ -n "$WINDOWMANAGER" ] ; then
      echo "$WINDOWMANAGER &"
      echo 'WINDOWMANAGERPID=$!'
      echo 'storepid $! '$WM_NAME
      # (adding pid to $XINITJOBSTOKILL later)
  fi
  #
  if [ "$SHOWLOGNEWDISPLAY" = "yes" ] ; then
      echo $XTERM' -title "x11docker xinit log '$IMAGENAME $IMAGECOMMAND'" -e "tail -F '$XINITLOGFILE $XTERMLOGFILE $DOCKERLOGFILE $XPRALOGFILE' 2> /dev/null" & '
      echo 'storepid $! xterm'
  fi
  #
  # option '-c, --clipboard': Run clipboard script for X11/Xephyr 
  # (text copy only) (xpra has its own clipboard managment including images)
  if [ "$SHARECLIPBOARD" = "yes" ] && [ ! "$XSERVER" = "XPRA" ] ; then
      echo "bash $SHARECLIPBOARDSCRIPT &"
      echo 'storepid $! bash'
  fi
  #
  case $XSERVER in
      XPRA) 
          ## start Xpra server on display created by Xvfb
          echo "xpra start $NEWDISPLAY --use-display --no-pulseaudio --no-daemon $XPRAARGS > $XPRASERVERLOGFILE 2>&1 &"
          echo 'XINITJOBSTOKILL="$XINITJOBSTOKILL $!"'
          echo 'storepid $! xpra'
          echo 'XPRAPID=$!'
          # wait for Xpra server to be ready
          echo 'ZEIT=`date +%s`'
          echo 'while [ -z "$(cat '$XPRASERVERLOGFILE' | grep '"'xpra is ready'"')" ] ; do'
          echo '    echo "waiting for xpra server to be ready..." && sleep 0.3 '
          echo '    COUNT=$(echo "`date +%s` - $ZEIT" | bc)'
          echo '    if [ 10 -lt $COUNT ] ; then'
          echo '        echo "x11docker: Timeout error: Xpra server not ready after 10 seconds. Exiting."'
          echo '        exit 1'
          echo '    fi'
          echo 'done'
          # check for X error
          echo 'if [ -n "$(cat '$XPRASERVERLOGFILE" | grep 'X Window System error')"'" ] ; then'
          echo '    echo "x11docker: Error: received an X Window System error. See '$XPRASERVERLOGFILE' for details. Exiting"'
          echo '    exit 1'
          echo 'fi'
          ## run xpra viewer
          # set X variables to display :0
          echo "export DISPLAY=$STARTDISPLAY"
          echo "export XAUTHORITY=$STARTXAUTHORITY"
          # start xpra viewer on display :0
          echo "xpra attach $NEWDISPLAY &"
          echo 'XINITJOBSTOKILL="$XINITJOBSTOKILL $!"'
          echo 'storepid $! xpra'
          # set X variables back to new display
          echo "export DISPLAY=$NEWDISPLAY"
          echo "export XAUTHORITY=$XCLIENTCOOKIE"
      ;;
      XEPHYR)
          echo "echo '$(setxkbmap -display $STARTDISPLAY -print)' | xkbcomp - $NEWDISPLAY"
      ;;
  esac
  #
  # disable any possible xhost granted access on new X server
  echo "no_xhost"
  if [ "$X11DOCKERMODE" = "run" ] && [ "$GPU" = "yes" ]; then :  # workaround until hardware acceleration with X over tcp in docker works
    # enable access of user in docker image to new display. Should be done with cookies only. ### SECURITY ISSUE
    echo "xhost +SI:localuser:$DOCKERUSER"
  fi
  #
  if [ -n "$XHOST" ] ; then echo "xhost $XHOST" ; fi # developer option --xhost
  #
  # choose apps to run and wait for them to exit
  case $X11DOCKERMODE in
    run) # password for docker will be prompted in xterm
        echo "xterm -l -lf $XTERMLOGFILE -title x11docker -e '/bin/bash $XTERMRC'"
        echo "if [ -e $DOCKERPIDFILE ] ; then"
        echo '    DOCKERPID=`cat '$DOCKERPIDFILE'`'
        echo '    storepid $DOCKERPID docker'
        echo '    set +x'
        echo '    while [ -n "$(pgrep docker | grep $DOCKERPID)" ] ; do'
        echo '        sleep 1'
        case $XSERVER in
          XPRA) # xpra server can crash for unknown reasons, especially with google earth in wine.
                # This may be catched here in future. Since I want to fix this, it doesn't happen to me anymore ...
          ;;
        esac
        echo '    done'
        echo '    set -x'
        echo 'fi'
        ;;
    exe) # run host application (window manager is already running)
        echo "$DOCKERARGS &"
        echo 'storepid $! '`echo $DOCKERARGS | awk '{print $1}'`
        echo 'wait $!'
        ;;
    onlyX) # wait for window manager to exit
        if [ "$(echo $WM_RECOMMENDED_NODESKTOP_LIGHT $WM_RECOMMENDED_NODESKTOP_HEAVY | grep $WM_NAME)" != "" ] ; then 
            # Show warning, if window manager has no logout opion
            echo $XTERM' -title "x11docker note" -e "echo'   " 'You can switch between your X Servers using <STRG><ALT><F7>...<F12>. 
As your chosen window manager $WM_NAME seems to have no logout option, 
you have no other way to leave this session. Maybe you want to choose
another window manager with option --wm next time. 
Recommended window managers with logout option are:
$WM_RECOMMENDED_DESKTOP_LIGHT $WM_RECOMMENDED_DESKTOP_HEAVY' ; read" '"'
        fi
        echo 'wait $WINDOWMANAGERPID'
        echo '$WINDOWMANAGERPID=""'
        ;;
  esac
  #
  # clean up background jobs
  # ($WINDOWMANAGERPID can already be empty, see case onlyX above. maybe window manager wasn't running at all)
  echo 'XINITJOBSTOKILL="$XINITJOBSTOKILL $WINDOWMANAGERPID"'
  echo 'for ARGUMENT in $XINITJOBSTOKILL ; do kill $ARGUMENT ; done'

  # option '--pulseaudio'. remove custom tcp module
  if [ "$PULSEAUDIO" = "yes" ] ; then 
    echo 'pactl unload-module $PULSE_MODULE_ID'  
  fi 
  
  if [ -n "$XHOST" ] ; then echo "xhost -" ; fi # developer option --xhost
} > $XINITRC

{ #### part: create xtermrc (used by xinitrc to get password and run docker)
  if [ "$X11DOCKERMODE" = "run" ] ; then
    { echo "#! /bin/bash"
    if [ "$WINDOWMANAGER" = "" ] && [ "$XSERVER" != "XPRA" ] ; then
        echo "echo 'Please move mouse cursor into terminal area to get keyboard focus.'"
    fi
    echo "echo 'x11docker will start docker on display $NEWDISPLAY with command:'"
    echo "echo $GETROOT '$COMMAND'"
    echo "echo 'Please type in your password:'"
    echo "$GETROOT 'nohup $COMMAND > $DOCKERLOGFILE 2>&1 & echo "'$!'" > $DOCKERPIDFILE'"
#    echo "$GETROOT 'nohup vglrun +v -- $COMMAND > $DOCKERLOGFILE 2>&1 & echo "'$!'" > $DOCKERPIDFILE'"
    echo "sleep 2" # time to read error message
    } > $XTERMRC
  fi   
}

{ #### part:  options '-v, --verbose', '-V, --VERBOSE': be [very] verbose
  if [ "$VERBOSE" = "yes" ] ; then
    verbose "Found free display $NEWDISPLAY"
    verbose "As X server will be used: $XSERVER"
    verbose "IP of docker interface is $DOCKERIP 
As display number for the container $TCPDISPLAY will be used."
    if [ "$ADDUSERHOME" = "yes" ] ; then verbose "Sharing folder $ADDUSERHOMEFOLDER with container as its home directory $HOME/$BENUTZER" ; fi
    verbose "Created docker command:
$COMMAND"
    verbose "Created X server command:
$XCOMMAND" 
    #
    # some infos about window manager
    #
    if [ "$WMCTRLINSTALLED" = "no" ] ; then
        warning "To autodetect your current window manager, x11docker
  needs package 'wmctrl' to be installed. Please consider to install 'wmctrl'
  with command: 'apt-get install wmctrl'"
    fi
    #
    verbose "Found window manager: '$WINDOWMANAGER'"
    case $WM_NAME in
    cinnamon)
        warning "Found cinnamon as window manager. Please don't use shutdown
  option of cinnamon, because it would shut down your main session, too."
        ;;
    compiz)
        verbose "compiz is a good choice for using as windowmanager in x11docker.
  If not already present, x11docker creates a minimal basic configuration for
  compiz. Run x11docker with command 'x11docker --wm compiz --exe ccsm' to be
  able to enable more features of compiz. If not already done, install ccsm
  with 'apt-get install compizconfig-settings-manager'
  Consider to use a more lightweight window manager with option '-w, --wm'"
        ;;
    kwin|enlightenment)
        verbose "As window manager $WINDOWMANAGER was found.
  This window manager works fine in x11docker, but is a bit heavy in memory
  and cpu usage. You could choose a smaller one with option '-w, --wm".
        ;;
    gnome-shell)
        warning "gnome-shell is possible, but not recommended for use in x11docker.
  Especially, it can crash if used within Xephyr.
  Consider to use another window manager with option '-w, --wm'.
  In your case, 'mutter' would be a good choice. You can install 'mutter'
  with 'apt-get install mutter'."
        ;;
    icewm)
        warning "IceWM is a good window manager. For use in x11docker, it has one
  drawback: You should not use the logout option of IceWM, because it will try to
  close your main session, too.
  Consider to use another window manager with option '-w, --wm'"
        ;;
    lxsession)
        verbose "lxsession is a good choice to have a comfortable window management
  and a usefull desktop environment in x11docker. Please don't use shutdown
  option of lxsession, because it would shut down your main session, too."
        ;;
    openbox)
        verbose "Window manager openbox is a good choice, as it is small, fast and
  comfortable. It has one small issue: The terminal window to type in your
  password doesn't raise on itself; you have to click on the screen to see the
  window and click it again to give it focus. 
  Consider to use another window manager with option '-w, --wm'"
    esac
    #
    verbose "Created xinitrc:
$(cat $XINITRC)"
    verbose "Created xtermrc:
$(cat $XTERMRC)"
    #
    # Logfiles
    #
    verbose "Logfiles are:
$XINITLOGFILE
$XPRASERVERLOGFILE
$XTERMLOGFILE
$DOCKERLOGFILE"
  fi
  
  # Show logfiles, tail -F follows them
  tail --retry -n +1 -F $XINITLOGFILE $XTERMLOGFILE $DOCKERLOGFILE $XPRALOGFILE 2> /dev/null &
  PIDSTOKILL="$PIDSTOKILL $!"
  storepid $! tail
}

{ #### part: option '--starter': create desktop starter & exit
  if [ "$CREATEDESKTOPSTARTER" = "yes" ] ; then
    X11DOCKERARGS=$(echo $X11DOCKERARGS | sed 's/--starter/ /')
    NAME="$(echo $IMAGENAME | tr / -) $(echo $IMAGECOMMAND | tr -cd '[:alpha:][:digit:][:blank:]-_.') x11docker"
    read -re -p "Please choose a name for your desktop starter: " -i "$NAME" NAME
    echo "#!/usr/bin/xdg-open
[Desktop Entry]
Type=Application
Name=$NAME
Exec=$0 $X11DOCKERARGS
Icon=system-run
Comment=
Categories=System
Keywords=docker $(echo $NAME | tr -c '[:alpha:][:digit:][:blank:]' ' ' )
TryExec=x11docker $X11DOCKERARGS
" > "`xdg-user-dir DESKTOP`/$NAME.desktop"
    verbose "Created desktop icon `xdg-user-dir DESKTOP`/$NAME.desktop"
    exit 0
  fi
}

{ #### Finally: run new X server
  # option '-l, --log': show logs in an xterm window on display :0
  if [ "$SHOWLOG" = "yes" ] ; then $XTERM -title "x11docker xinit log $IMAGENAME $IMAGECOMMAND" -e "tail --retry -n +1 -F $XINITLOGFILE $XTERMLOGFILE $DOCKERLOGFILE $XPRALOGFILE 2> /dev/null" ; fi &
#  case $XSERVER in
#    XPRA)   $XCOMMAND --start-child="bash $XINITRC" > $XINITLOGFILE 2>&1 ;;
#    *)      xinit $XINITRC -- $XCOMMAND  > $XINITLOGFILE 2>&1 ;;
#  esac
  xinit $XINITRC -- $XCOMMAND  > $XINITLOGFILE 2>&1
  exit 0         # trap EXIT will start finish()
}
